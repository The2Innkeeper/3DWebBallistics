<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ballistics Simulation</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
</head>

<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.6/build/dat.gui.min.js"></script>
<script>
    // Setup scene, camera, renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Add orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 5, 30);
    controls.update();

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    // Create a sphere
    const geometry = new THREE.SphereGeometry(0.5, 32, 32);
    const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // Ground plane
    const planeGeometry = new THREE.PlaneGeometry(100, 100);
    const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    scene.add(plane);

    // Grid helper
    const gridHelper = new THREE.GridHelper(100, 100);
    scene.add(gridHelper);

    // Simulation parameters
    let animationActive = false;
    const params = {
        velocity: 20,
        angle: 45,
        gravity: -9.81,
        timeScale: 1, // Control the simulation speed
        startAnimation: function () { animationActive = true; },
        stopAnimation: function () { animationActive = false; resetSimulation(); }
    };

    // GUI controls
    const gui = new dat.GUI();
    gui.add(params, 'velocity', 1, 100).name('Velocity').onChange(resetSimulation);
    gui.add(params, 'angle', 0, 90).name('Launch Angle').onChange(resetSimulation);
    gui.add(params, 'gravity', -20, 0).name('Gravity').onChange(resetSimulation);
    gui.add(params, 'timeScale', 0.1, 2).name('Time Scale');
    gui.add(params, 'startAnimation').name('Start Animation');
    gui.add(params, 'stopAnimation').name('Stop Animation');

    // Function to reset the simulation
    function resetSimulation() {
        time = 0;
        sphere.position.set(0, 0, 0);
    }

    // Continuous render loop
    function render() {
        requestAnimationFrame(render);
        controls.update(); // Update camera controls
        renderer.render(scene, camera);
    }

    // Time management
    let time = 0;
    let lastTime = 0;

    // Animation loop
    function animate(currentTime) {
        if (animationActive) {
            const deltaTime = (currentTime - lastTime) * 0.001 * params.timeScale;
            lastTime = currentTime;

            // Use deltaTime for time increment
            time += deltaTime;

            // Calculate new positions
            const angleRad = params.angle * (Math.PI / 180);
            let posX = params.velocity * Math.cos(angleRad) * time;
            let posY = (params.velocity * Math.sin(angleRad) * time) + (0.5 * params.gravity * Math.pow(time, 2));

            sphere.position.x = posX;
            sphere.position.y = posY;

            // Reset if the sphere hits the ground
            if (sphere.position.y < 0) {
                params.stopAnimation(); // Stop the animation when the sphere hits the ground
            }
        } else {
            lastTime = currentTime; // Ensure smooth restart
        }

        requestAnimationFrame(animate);
    }

    render(); // Start the continuous rendering loop
    animate(0); // Start the animation loop
</script>


</body>

</html>
