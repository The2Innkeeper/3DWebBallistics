{"mappings":"ACCA,IAAI,EAAkB,CAAA,EACtB,MAAM,EAAS,CACX,SAAU,GACV,MAAO,GACP,QAAS,MACT,UAAW,EACX,eAAgB,WAAc,EAAkB,CAAA,CAAM,EACtD,cAAe,WAAc,EAAkB,CAAA,EAAO,GAAmB,CAC7E,EAGM,EAAM,IAAI,IAAI,GAAG,CASvB,SAAS,IACL,EAAO,EACP,OAAO,QAAQ,CAAC,GAAG,CAAC,EAAG,EAAG,EAC9B,CAXA,EAAI,GAAG,CAAC,EAAQ,WAAY,EAAG,KAAK,IAAI,CAAC,YAAY,QAAQ,CAAC,GAC9D,EAAI,GAAG,CAAC,EAAQ,QAAS,EAAG,IAAI,IAAI,CAAC,gBAAgB,QAAQ,CAAC,GAC9D,EAAI,GAAG,CAAC,EAAQ,UAAW,IAAK,GAAG,IAAI,CAAC,WAAW,QAAQ,CAAC,GAC5D,EAAI,GAAG,CAAC,EAAQ,YAAa,GAAK,GAAG,IAAI,CAAC,cAC1C,EAAI,GAAG,CAAC,EAAQ,kBAAkB,IAAI,CAAC,mBACvC,EAAI,GAAG,CAAC,EAAQ,iBAAiB,IAAI,CAAC,kBAgBtC,IAAI,EAAO,EACP,EAAW,GA8Bf,AAtCA,SAAS,IACL,sBAAsB,GACtB,SAAS,MAAM,GACf,SAAS,MAAM,CAAC,MAAO,OAC3B,IAmCA,AA5BA,SAAS,EAAQ,CAAW,EACxB,GAAI,EAAiB,CACjB,IAAM,EAAY,AAAC,CAAA,EAAc,CAAA,EAAY,KAAQ,EAAO,SAAS,CACrE,EAAW,EAGX,GAAQ,EAGR,IAAM,EAAW,EAAO,KAAK,CAAI,CAAA,KAAK,EAAE,CAAG,GAAA,EACvC,EAAO,EAAO,QAAQ,CAAG,KAAK,GAAG,CAAC,GAAY,EAC9C,EAAO,EAAQ,QAAQ,CAAG,KAAK,GAAG,CAAC,GAAY,EAAS,GAAM,EAAO,OAAO,CAAG,KAAK,GAAG,CAAC,EAAM,EAElG,CAAA,OAAO,QAAQ,CAAC,CAAC,CAAG,EACpB,OAAO,QAAQ,CAAC,CAAC,CAAG,EAGhB,OAAO,QAAQ,CAAC,CAAC,CAAG,GACpB,EAAO,aAAa,EAE5B,MACI,EAAW,EAGf,sBAAsB,EAC1B,EAGQ","sources":["<anon>","src/js/main.js"],"sourcesContent":["// Simulation parameters\nlet animationActive = false;\nconst params = {\n    velocity: 20,\n    angle: 45,\n    gravity: -9.81,\n    timeScale: 1,\n    startAnimation: function() {\n        animationActive = true;\n    },\n    stopAnimation: function() {\n        animationActive = false;\n        resetSimulation();\n    }\n};\n// GUI controls\nconst gui = new dat.GUI();\ngui.add(params, \"velocity\", 1, 100).name(\"Velocity\").onChange(resetSimulation);\ngui.add(params, \"angle\", 0, 90).name(\"Launch Angle\").onChange(resetSimulation);\ngui.add(params, \"gravity\", -20, 0).name(\"Gravity\").onChange(resetSimulation);\ngui.add(params, \"timeScale\", 0.1, 2).name(\"Time Scale\");\ngui.add(params, \"startAnimation\").name(\"Start Animation\");\ngui.add(params, \"stopAnimation\").name(\"Stop Animation\");\n// Function to reset the simulation\nfunction resetSimulation() {\n    time = 0;\n    sphere.position.set(0, 0, 0);\n}\n// Continuous render loop\nfunction render() {\n    requestAnimationFrame(render);\n    controls.update(); // Update camera controls\n    renderer.render(scene, camera);\n}\n// Time management\nlet time = 0;\nlet lastTime = 0;\n// Animation loop\nfunction animate(currentTime) {\n    if (animationActive) {\n        const deltaTime = (currentTime - lastTime) * 0.001 * params.timeScale;\n        lastTime = currentTime;\n        // Use deltaTime for time increment\n        time += deltaTime;\n        // Calculate new positions\n        const angleRad = params.angle * (Math.PI / 180);\n        let posX = params.velocity * Math.cos(angleRad) * time;\n        let posY = params.velocity * Math.sin(angleRad) * time + 0.5 * params.gravity * Math.pow(time, 2);\n        sphere.position.x = posX;\n        sphere.position.y = posY;\n        // Reset if the sphere hits the ground\n        if (sphere.position.y < 0) params.stopAnimation(); // Stop the animation when the sphere hits the ground\n    } else lastTime = currentTime; // Ensure smooth restart\n    requestAnimationFrame(animate);\n}\nrender(); // Start the continuous rendering loop\nanimate(0); // Start the animation loop\n\n//# sourceMappingURL=index.bbb074d1.js.map\n","// Simulation parameters\nlet animationActive = false;\nconst params = {\n    velocity: 20,\n    angle: 45,\n    gravity: -9.81,\n    timeScale: 1, // Control the simulation speed\n    startAnimation: function () { animationActive = true; },\n    stopAnimation: function () { animationActive = false; resetSimulation(); }\n};\n\n// GUI controls\nconst gui = new dat.GUI();\ngui.add(params, 'velocity', 1, 100).name('Velocity').onChange(resetSimulation);\ngui.add(params, 'angle', 0, 90).name('Launch Angle').onChange(resetSimulation);\ngui.add(params, 'gravity', -20, 0).name('Gravity').onChange(resetSimulation);\ngui.add(params, 'timeScale', 0.1, 2).name('Time Scale');\ngui.add(params, 'startAnimation').name('Start Animation');\ngui.add(params, 'stopAnimation').name('Stop Animation');\n\n// Function to reset the simulation\nfunction resetSimulation() {\n    time = 0;\n    sphere.position.set(0, 0, 0);\n}\n\n// Continuous render loop\nfunction render() {\n    requestAnimationFrame(render);\n    controls.update(); // Update camera controls\n    renderer.render(scene, camera);\n}\n\n// Time management\nlet time = 0;\nlet lastTime = 0;\n\n// Animation loop\nfunction animate(currentTime) {\n    if (animationActive) {\n        const deltaTime = (currentTime - lastTime) * 0.001 * params.timeScale;\n        lastTime = currentTime;\n\n        // Use deltaTime for time increment\n        time += deltaTime;\n\n        // Calculate new positions\n        const angleRad = params.angle * (Math.PI / 180);\n        let posX = params.velocity * Math.cos(angleRad) * time;\n        let posY = (params.velocity * Math.sin(angleRad) * time) + (0.5 * params.gravity * Math.pow(time, 2));\n\n        sphere.position.x = posX;\n        sphere.position.y = posY;\n\n        // Reset if the sphere hits the ground\n        if (sphere.position.y < 0) {\n            params.stopAnimation(); // Stop the animation when the sphere hits the ground\n        }\n    } else {\n        lastTime = currentTime; // Ensure smooth restart\n    }\n\n    requestAnimationFrame(animate);\n}\n\nrender(); // Start the continuous rendering loop\nanimate(0); // Start the animation loop"],"names":["animationActive","params","velocity","angle","gravity","timeScale","startAnimation","stopAnimation","resetSimulation","gui","dat","GUI","time","sphere","position","set","add","name","onChange","lastTime","render","requestAnimationFrame","controls","update","renderer","scene","camera","animate","currentTime","deltaTime","angleRad","Math","PI","posX","cos","posY","sin","pow","x","y"],"version":3,"file":"index.bbb074d1.js.map"}